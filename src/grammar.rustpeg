use crate::ast::*;

_ = #quiet<[ \t]*>

//any whitespace, must include at least one newline
__ = [ \t]* "\n" [ \t\n]*

pub expression -> Expr<'input> = fun_call / number_literal / deref / var / var_address

pub ident -> &'input str = i:$([a-zA-Z0-9]+)
    { i }

decimal -> Expr<'input> = n:$([0-9]+)
    { Expr::Literal(n.parse::<u32>().unwrap()) }

hex -> Expr<'input> = "0x" n:$([0-9A-Fa-f]+)
    { Expr::Literal(u32::from_str_radix(n, 16).unwrap()) }

binary -> Expr<'input> = "0b" n:$([0-1]+)
    { Expr::Literal(u32::from_str_radix(n, 2).unwrap()) }

number_literal -> Expr<'input> = binary / hex / decimal

deref -> Expr<'input> = "[" _ e:expression _ "]" 
    { Expr::Deref(Box::new(e)) }

var -> Expr<'input> = i:ident
    { Expr::Var(i) }

var_address -> Expr<'input> = "&" _ i:ident
    { Expr::VarAddress(i) }

padded_expression -> Expr<'input> = _ e:expression _
    { e }

fun_call -> Expr<'input> = i:ident _ "(" args:(padded_expression ++ ",") ")"
    { Expr::FunCall(i, args) }

arithmetic -> Expr<'input> = #infix<padded_expression> {
    #L  x "+" y { Expr::Add(Box::new(x), Box::new(y)) }
        x "-" y { Expr::Sub(Box::new(x), Box::new(y)) }
    #L  x "*" y { Expr::Mul(Box::new(x), Box::new(y)) }
        x "/" y { Expr::Div(Box::new(x), Box::new(y)) }
    #L  x "<" y { Expr::Lt(Box::new(x), Box::new(y)) }
        x ">" y { Expr::Gt(Box::new(x), Box::new(y)) }
        x "<=" y { Expr::Leq(Box::new(x), Box::new(y)) }
        x ">=" y { Expr::Geq(Box::new(x), Box::new(y)) }
        x "=" y { Expr::Eq(Box::new(x), Box::new(y)) }
        x "!=" y { Expr::Neq(Box::new(x), Box::new(y)) }
}

line -> Line<'input> = fun_declaration / label / for_loop / assign / while_loop / if_else / if_block / goto / expr_line

assign -> Line<'input> = e:expression _ "->" _ i:ident
    { Line::Assign(i, e) }

pub lines -> Block<'input> = l:(line ++ __)
    { l }

for_loop -> Line<'input> = "for" _ i:ident _ "," _ start:expression _ "," _ end:expression __ l:lines __ "end"
    { Line::For(i, start, end, l) }

while_loop -> Line<'input> = "while" _ e:expression __ l:lines __ "end"
    { Line::While(e, l) }

if_else -> Line<'input> = "if" _ e:expression __ l:lines __ "else" __ ll:lines __ "end"
    { Line::If(e, l, Some(ll))}

if_block -> Line<'input> = "if" _ e:expression __ l:lines __ "end"
    { Line::If(e, l, None) }

goto -> Line<'input> = "goto" _ n:ident
    { Line::Goto(n) }

label -> Line<'input> = n:ident _ ":"
    { Line::Label(n) }
 
fun_arg -> &'input str = _ i:ident _
    { i }

fun_declaration -> Line<'input> = "func" _ i:ident _ "(" args:(fun_arg ++ ",") ")" __ l:lines __ "end"
    { Line::FunDeclaration(i, args, l) }

expr_line -> Line<'input> = e:fun_call
    { Line::Expr(e) }