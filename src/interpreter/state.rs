//! The InterpreterState struct handles most of the moving parts of the interpreter.

use crate::error::Error;
use super::intrinsics::try_execute_intrinsic;
use super::{IResult, Program};
use crate::ast::{AssignTarget, Expr};
use crate::graphics::{Graphics, Sprites};
use crate::intermediate_repr::IntermediateLine;

use std::collections::HashMap;

/// Mutable state that is able to execute lines of a Program.
pub struct InterpreterState<'a> {
    /// The interpreter's memory segment (contains variables and user defined data)
    pub data: Vec<u8>,
    /// Maps vars (as they are created) to their location (byte index) in the data vec
    pub var_table: HashMap<&'a str, usize>,
    /// current instruction pointer
    pub instr_index: usize,

    pub graphics: Graphics,
    pub sprites: Sprites<'a>,
}

impl<'a> InterpreterState<'a> {
    /// Execute a single line based on the current state (instr pointer)
    ///
    /// Note, this may actually execute several lines because function calls
    /// in the current line will jump to the function definition and fully execute
    /// before returning to the current line.
    pub fn execute_line(&mut self, program: &Program<'a>) -> IResult<()> {
        let line = &program.ir[self.instr_index];
        use IntermediateLine::*;

        match line {
            Assign(target, expr) => {
                let value_to_assign = self.evaluate_expr(expr, program)?;
                match target {
                    AssignTarget::Var(name) => {
                        let store_address = self.get_var_address(name);
                        self.set_memory_u32(store_address, value_to_assign)?;
                    }
                    AssignTarget::Addr(addr) => {
                        let store_address = self.evaluate_expr(addr, program)?;
                        self.set_memory_u32(store_address as usize, value_to_assign)?;
                    }
                    AssignTarget::ByteAddr(addr) => {
                        let store_address = self.evaluate_expr(addr, program)?;
                        // truncate u32 expression into a byte,
                        // and store it into a single byte of the data vec
                        self.set_memory_u8(store_address as usize, value_to_assign as u8)?;
                    }
                }
            }

            Expr(expr) => {
                self.evaluate_expr(expr, program)?;
            }

            JumpFalse(expr, label) => {
                let expr_result = self.evaluate_expr(expr, program)?;
                if expr_result == 0 {
                    // Do not need to error check the hashmap get because
                    // JumpFalse are only generated by intermediate_repr, so the label will always exist
                    self.instr_index = program.label_table[label];
                }
            }

            // Ignore labels, function decls, and function returns
            // Note, this means that execution can fall through into functions (TODO intended?)
            Label(..) | FunDeclaration(..) | FunReturn => {}
            Goto(name) => {
                self.instr_index = *program
                    .label_table
                    .get(name)
                    .ok_or_else(|| Error::LabelNotFound(name.to_string()))?;
            }
        };
        self.instr_index += 1;
        Ok(())
    }

    /// Evaluate expression and return its result as u32
    /// Note, this will run any functions called in the expr and obtain their result
    fn evaluate_expr(&mut self, expr: &Expr<'a>, program: &Program<'a>) -> IResult<u32> {
        use Expr::*;
        // TODO macro for this?
        match expr {
            Literal(n) => Ok(*n),
            Add(l, r) => self.bin_op(&l, &r, program, |a, b| a.wrapping_add(b)),
            Sub(l, r) => self.bin_op(&l, &r, program, |a, b| a.wrapping_sub(b)),
            Mul(l, r) => self.bin_op(&l, &r, program, |a, b| a * b),
            Div(l, r) => self.bin_op(&l, &r, program, |a, b| a / b),
            Mod(l, r) => self.bin_op(&l, &r, program, |a, b| a % b),
            BitAnd(l, r) => self.bin_op(&l, &r, program, |a, b| a & b),
            BitOr(l, r) => self.bin_op(&l, &r, program, |a, b| a | b),
            BitXor(l, r) => self.bin_op(&l, &r, program, |a, b| a ^ b),
            Shl(l, r) => self.bin_op(&l, &r, program, |a, b| a << b),
            Shr(l, r) => self.bin_op(&l, &r, program, |a, b| a >> b),
            Lt(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a < b),
            Gt(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a > b),
            Leq(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a <= b),
            Geq(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a >= b),
            Neq(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a != b),
            Eq(l, r) => self.bin_bool_op(&l, &r, program, |a, b| a == b),

            // LOGICAL inversion
            Invert(e) => Ok(if self.evaluate_expr(e, program)? == 0 {
                1
            } else {
                0
            }),

            FunCall(name, args) => {
                let evaluated_args = args
                    .iter()
                    .map(|e| self.evaluate_expr(e, program))
                    .collect::<Result<Vec<u32>, Error>>()?;
                self.evaluate_funcall(name, &evaluated_args, program)
            }

            Var(name) => self.get_var_value(name),
            Deref(addr_expr) => {
                let addr = self.evaluate_expr(addr_expr, program)?;
                self.get_memory_u32(addr as usize)
            }
            DerefByte(addr_expr) => {
                let addr = self.evaluate_expr(addr_expr, program)? as usize;
                self.get_memory_u8(addr).map(u32::from)
            }
            VarAddress(name) => Ok(self.get_var_address(name) as u32),
        }
    }

    /// Evaluate a binary operation (defined by operation parameter) on the left and right expression
    fn bin_op<F>(
        &mut self,
        left: &Expr<'a>,
        right: &Expr<'a>,
        program: &Program<'a>,
        operation: F,
    ) -> IResult<u32>
    where
        F: Fn(u32, u32) -> u32,
    {
        let l = self.evaluate_expr(left, program)?;
        let r = self.evaluate_expr(right, program)?;
        Ok(operation(l, r))
    }

    /// Evaluate a binary operation (defined by operation parameter) that returns a bool (1 or 0 int)
    fn bin_bool_op<F>(
        &mut self,
        left: &Expr<'a>,
        right: &Expr<'a>,
        program: &Program<'a>,
        operation: F,
    ) -> IResult<u32>
    where
        F: Fn(u32, u32) -> bool,
    {
        let l = self.evaluate_expr(left, program)?;
        let r = self.evaluate_expr(right, program)?;

        if operation(l, r) {
            Ok(1)
        } else {
            Ok(0)
        }
    }

    /// Executes a function (defined by name) and returns its result
    /// May be an intrinsic function or a user defined one
    fn evaluate_funcall(
        &mut self,
        name: &str,
        args: &[u32],
        program: &Program<'a>,
    ) -> IResult<u32> {
        try_execute_intrinsic(name, args, self).unwrap_or_else(|| {
            //try_execute_intrinsic return false, so search for a user function of the specified name

            let return_instr_index = self.instr_index;

            //jump to function
            self.instr_index = *program
                .label_table
                .get(name)
                .ok_or_else(|| Error::FunctionNotFound(name.to_string()))?;

            if let IntermediateLine::FunDeclaration(_, params, is_savearg) =
                &program.ir[self.instr_index]
            {
                if params.len() != args.len() {
                    return Err(Error::ArgumentMismatch {
                        expected: params.len(),
                        got: args.len(),
                        func_name: name.to_string(),
                    });
                }

                let saved_args = if *is_savearg {
                    Some(self.save_func_params(params)?)
                } else {
                    None
                };

                for (index, param) in params.iter().enumerate() {
                    let addr = self.get_var_address(param);
                    let arg_value = args[index];
                    self.set_memory_u32(addr, arg_value)?;
                }

                loop {
                    if let IntermediateLine::FunReturn = program.ir[self.instr_index] {
                        break;
                    }
                    self.execute_line(program)?;
                }

                if let Some(saved_args) = saved_args {
                    self.restore_func_params(&saved_args)?
                };

                self.instr_index = return_instr_index;
                self.get_var_value("ans")
            } else {
                // if the jump did not lead to a FunDeclaration (ie. trying to call a label like a function)
                Err(Error::NameIsNotFunction(name.to_string()))
            }
        })
    }

    /// Access a u32 at the specified *byte* index. Error on out of bounds.
    fn get_memory_u32(&self, index: usize) -> IResult<u32> {
        if index + 3 >= self.data.len() {
            Err(Error::U32OutOfBounds {
                u32_read_index: index,
                memory_length: self.data.len(),
            })
        } else {
            Ok(u32::from_le_bytes([
                self.data[index],
                self.data[index + 1],
                self.data[index + 2],
                self.data[index + 3],
            ]))
        }
    }

    /// Set the 4 bytes at the specified *byte* index to the value, big endian. Error on out of bounds.
    fn set_memory_u32(&mut self, index: usize, value: u32) -> IResult<()> {
        if index + 3 >= self.data.len() {
            Err(Error::U32OutOfBounds {
                u32_read_index: index,
                memory_length: self.data.len(),
            })
        } else {
            let bytes = value.to_le_bytes();
            self.data[index] = bytes[0];
            self.data[index + 1] = bytes[1];
            self.data[index + 2] = bytes[2];
            self.data[index + 3] = bytes[3];
            Ok(())
        }
    }

    /// Get byte of memory at the specified index. Error on out of bounds.
    pub fn get_memory_u8(&self, index: usize) -> IResult<u8> {
        self.data.get(index).copied().ok_or(Error::U8OutOfBounds {
            u8_read_index: index,
            memory_length: self.data.len(),
        })
    }

    /// Set byte of memory at index to the given value. Error on out of bounds.
    fn set_memory_u8(&mut self, index: usize, value: u8) -> IResult<()> {
        if index < self.data.len() {
            self.data[index] = value;
            Ok(())
        } else {
            Err(Error::U8OutOfBounds {
                u8_read_index: index,
                memory_length: self.data.len(),
            })
        }
    }

    /// Returns value of var based on data vec and var table.
    /// As with get_var_addres, it allocates space for a variable and
    /// returns the alloc'd space if the var doesn't exist
    fn get_var_value(&mut self, name: &'a str) -> IResult<u32> {
        let addr = self.get_var_address(name);
        self.get_memory_u32(addr)
    }

    /// Returns the address in memory (data vec) that a var points to.
    /// If the var does not already exist, append a slot to memory and point the var's name to the new slot
    fn get_var_address(&mut self, name: &'a str) -> usize {
        if self.var_table.contains_key(name) {
            self.var_table[name]
        } else {
            let next_addr_in_data = self.data.len();
            self.var_table.insert(name, next_addr_in_data);
            // push 4 bytes (to fit a u32 variable)
            self.data.push(0);
            self.data.push(0);
            self.data.push(0);
            self.data.push(0);
            next_addr_in_data
        }
    }

    /// Look up all the vars specivied in the params slice and return a map of their name->value (vec of tuples)
    fn save_func_params(&mut self, params: &[&'a str]) -> IResult<Vec<(&'a str, u32)>> {
        params
            .iter()
            .map(|param| {
                self.get_var_value(param)
                    .map(|param_value_ok| (*param, param_value_ok))
            })
            .collect()
    }

    /// For all the specivied var names and values in saved_params, restore the specified name to the specified value
    fn restore_func_params(&mut self, saved_params: &[(&'a str, u32)]) -> IResult<()> {
        for (var_name, value) in saved_params {
            let addr = self.get_var_address(var_name);
            self.set_memory_u32(addr, *value)?;
        }
        Ok(())
    }
}
